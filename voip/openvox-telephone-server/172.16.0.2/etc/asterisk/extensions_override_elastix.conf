
[macro-hangupcall]
include => macro-hangupcall-custom

; Validar si el archivo de MixMon existe. Puede no existir si la llamada cuelga
; del lado origen antes que el destino conteste (Elastix bug #422)
exten => s,1,GotoIf($["${CDR(userfield)}" = ""]?endmixmoncheck)
; Este codigo es fragil. Actualizar si se averigua la manera de consultar AST_MONITOR_DIR
exten => s,n,Set(MIXMON_CALLFILENAME=/var/spool/asterisk/monitor/${CALLFILENAME}.${MIXMON_FORMAT})
exten => s,n,GotoIf($["${MIXMON_DIR}" = ""]?defaultmixmondir)
exten => s,n,Set(MIXMON_CALLFILENAME=${MIXMON_DIR}${CALLFILENAME}.${MIXMON_FORMAT})
exten => s,n(defaultmixmondir),System(test -e ${MIXMON_CALLFILENAME})
exten => s,n,Noop(SYSTEMSTATUS = ${SYSTEMSTATUS})
exten => s,n,GotoIf($["${SYSTEMSTATUS}" = "SUCCESS"]?endmixmoncheck)
; Si archivo MixMon no existe, se anula CDR(userfield)
exten => s,n,Set(CDR(userfield)=)
exten => s,n(endmixmoncheck),Noop(End of MIXMON check)

; Validar si existe el archivo de grabacion de MeetMe. Puede que el archivo de
; grabacion sea distinto del especificado en el contexto, porque solo obedece
; la asignacion del primer conferencista que entra a la conferencia.
exten => s,n,GotoIf($["${MEETME_RECORDINGFILE}" = ""]?nomeetmemon)
exten => s,n,GotoIf($["${MEETME_RECORDINGFILE}" = "${MEETME_ACTUAL_RECORDINGFILE}"]?nomeetmemon2)
exten => s,n,System(ln ${MEETME_ACTUAL_RECORDINGFILE}.${MIXMON_FORMAT} ${MEETME_RECORDINGFILE}.${MIXMON_FORMAT})
exten => s,n(nomeetmemon2),Noop(MEETME_RECORDINGFILE and MEETME_ACTUAL_RECORDINGFILE are identical.)
exten => s,n,Set(CDR(userfield)=audio:${MEETME_RECORDINGFILE}.${MIXMON_FORMAT})
exten => s,n(nomeetmemon),Noop(MEETME_RECORDINGFILE=${MEETME_RECORDINGFILE})

; Validar si existe el archivo de grabacion bajo demanda para la extension
exten => s,n,GotoIf($["${TOUCH_MONITOR_OUTPUT}" = ""]?noautomon)
exten => s,n,Set(CDR(userfield)=audio:${TOUCH_MONITOR_OUTPUT}.${MIXMON_FORMAT})
exten => s,n(noautomon),Noop(TOUCH_MONITOR_OUTPUT=${TOUCH_MONITOR_OUTPUT})

; Validar si existe el archivo de grabacion de la cola
exten => s,n,GotoIf($["${MONITOR_FILENAME}" = ""]?noautomon2)
exten => s,n,System(test -e ${MONITOR_FILENAME}*)
exten => s,n,Noop(SYSTEMSTATUS = ${SYSTEMSTATUS})
exten => s,n,GotoIf($["${SYSTEMSTATUS}" = "APPERROR"]?errornoautomon)
exten => s,n,Set(CDR(userfield)=audio:${MONITOR_FILENAME})
exten => s,n(errornoautomon),Noop(End of MONITOR QUEUE check)
exten => s,n(noautomon2),Noop(MONITOR_FILENAME=${MONITOR_FILENAME})

exten => s,n(start),GotoIf($["${USE_CONFIRMATION}"="" | "${RINGGROUP_INDEX}"="" | "${CHANNEL}"!="${UNIQCHAN}"]?skiprg)
exten => s,n,Noop(Cleaning Up Confirmation Flag: RG/${RINGGROUP_INDEX}/${CHANNEL})
exten => s,n(delrgi),Noop(Deleting: RG/${RINGGROUP_INDEX}/${CHANNEL} ${DB_DELETE(RG/${RINGGROUP_INDEX}/${CHANNEL})})
exten => s,n(skiprg),GotoIf($["${BLKVM_BASE}"="" | "BLKVM/${BLKVM_BASE}/${CHANNEL}"!="${BLKVM_OVERRIDE}"]?skipblkvm)
exten => s,n,Noop(Cleaning Up Block VM Flag: ${BLKVM_OVERRIDE})
exten => s,n(delblkvm),Noop(Deleting: ${BLKVM_OVERRIDE} ${DB_DELETE(${BLKVM_OVERRIDE})})
exten => s,n(skipblkvm),GotoIf($["${FMGRP}"="" | "${FMUNIQUE}"="" | "${CHANNEL}"!="${FMUNIQUE}"]?theend)
exten => s,n(delfmrgp),Noop(Deleting: FM/DND/${FMGRP}/${CHANNEL} ${DB_DELETE(FM/DND/${FMGRP}/${CHANNEL})})
exten => s,n(theend),Hangup



[macro-record-enable]
include => macro-record-enable-custom
exten => s,1,GotoIf($["${BLINDTRANSFER}" = ""]?check)
exten => s,n,ResetCDR(w)
exten => s,n,StopMixMonitor()
exten => s,n(check),ExecIf($["${ARG1}"=""]?MacroExit())
exten => s,n,GotoIf($["${ARG2}"="Group"]?Group:OUT)
exten => s,n(Group),Set(LOOPCNT=${FIELDQTY(ARG1,-)})
exten => s,n,Set(ITER=1)
exten => s,n(begin),GotoIf($["${CUT(DB(AMPUSER/${CUT(ARG1,-,${ITER})}/recording),=,3)}" != "Always"]?continue)
exten => s,n,Set(TEXTEN=${CUT(ARG1,-,${ITER})})
exten => s,n,Noop(Recording enable for ${TEXTEN})
exten => s,n,Set(CALLFILENAME=g${TEXTEN}-${STRFTIME(${EPOCH},,%Y%m%d-%H%M%S)}-${UNIQUEID})
exten => s,n,Goto(record)
exten => s,n(continue),Set(ITER=$[${ITER}+1])
exten => s,n,GotoIf($[${ITER}<=${LOOPCNT}]?begin)
exten => s,n(OUT),GotoIf($["${ARG2}"="IN"]?IN)
exten => s,n,ExecIf($["${CUT(DB(AMPUSER/${ARG1}/recording),\\\|,1):4}" != "Always"]?MacroExit())
exten => s,n,Noop(Recording enable for ${ARG1})
exten => s,n,Set(CALLFILENAME=OUT${ARG1}-${STRFTIME(${EPOCH},,%Y%m%d-%H%M%S)}-${UNIQUEID})
exten => s,n,Goto(record)
exten => s,n(IN),ExecIf($["${CUT(DB(AMPUSER/${ARG1}/recording),\\\|,2):3}" != "Always"]?MacroExit())
exten => s,n,Noop(Recording enable for ${ARG1})
exten => s,n,Set(CALLFILENAME=${STRFTIME(${EPOCH},,%Y%m%d-%H%M%S)}-${UNIQUEID})
exten => s,n(record),MixMonitor(${MIXMON_DIR}${CALLFILENAME}.${MIXMON_FORMAT},,${MIXMON_POST})
exten => s,n,Set(CDR(userfield)=audio:${CALLFILENAME}.${MIXMON_FORMAT})
exten => s,n,MacroExit()
